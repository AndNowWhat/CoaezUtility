<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/AddRunesState.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/AddRunesState.java" />
              <option name="updatedContent" value="package net.botwithus.tasks;&#10;&#10;public class AddRunesState implements UrnTaskState {&#10;    @Override&#10;    public void handle(ClayUrnTask context) {&#10;        context.handleAddRunesToUrns();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/ClayUrnTask.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/ClayUrnTask.java" />
              <option name="originalContent" value="package net.botwithus.tasks;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;import java.util.regex.Pattern;&#10;&#10;import net.botwithus.CoaezUtility;&#10;import net.botwithus.api.game.hud.inventories.Backpack;&#10;import net.botwithus.api.game.hud.inventories.Bank;&#10;import net.botwithus.api.game.hud.inventories.DepositBox;&#10;import net.botwithus.rs3.game.Client;&#10;import net.botwithus.rs3.game.Distance;&#10;import net.botwithus.rs3.game.Item;&#10;import net.botwithus.rs3.game.hud.interfaces.Interfaces;&#10;import net.botwithus.rs3.game.js5.types.EnumType;&#10;import net.botwithus.rs3.game.js5.types.ItemType;&#10;import net.botwithus.rs3.game.js5.types.configs.ConfigManager;&#10;import net.botwithus.rs3.game.js5.types.vars.VarDomainType;&#10;import net.botwithus.rs3.game.minimenu.MiniMenu;&#10;import net.botwithus.rs3.game.minimenu.actions.ComponentAction;&#10;import net.botwithus.rs3.game.queries.builders.components.ComponentQuery;&#10;import net.botwithus.rs3.game.queries.builders.objects.SceneObjectQuery;&#10;import net.botwithus.rs3.game.queries.results.EntityResultSet;&#10;import net.botwithus.rs3.game.scene.entities.characters.Headbar;&#10;import net.botwithus.rs3.game.scene.entities.object.SceneObject;&#10;import net.botwithus.rs3.game.vars.VarManager;&#10;import net.botwithus.rs3.script.Execution;&#10;import net.botwithus.rs3.script.ScriptConsole;&#10;import net.botwithus.rs3.game.hud.interfaces.Component;&#10;&#10;public class ClayUrnTask implements Task {&#10;    private final CoaezUtility script;&#10;    &#10;    // Enum ID for pottery crafting groups&#10;    private static final int POTTERY_GROUP_ENUM_ID = 7004;&#10;    &#10;    // Dynamic urn categories and types loaded from game data&#10;    private List&lt;UrnCategory&gt; availableCategories;&#10;    private List&lt;UrnType&gt; availableUrns;&#10;    &#10;    // Default selections - will be updated when data is loaded&#10;    private UrnCategory selectedCategory;&#10;    private UrnType selectedUrn;&#10;    &#10;    public static class UrnCategory {&#10;        private final int index;&#10;        private final String displayName;&#10;        private final int enumId;&#10;        &#10;        public UrnCategory(int index, String displayName, int enumId) {&#10;            this.index = index;&#10;            this.displayName = displayName;&#10;            this.enumId = enumId;&#10;        }&#10;        &#10;        public int getIndex() { return index; }&#10;        public String getDisplayName() { return displayName; }&#10;        public int getEnumId() { return enumId; }&#10;        &#10;        @Override&#10;        public String toString() {&#10;            return displayName;&#10;        }&#10;    }&#10;    &#10;    public static class UrnType {&#10;        private final int id;&#10;        private final String displayName;&#10;        private final UrnCategory category;&#10;        &#10;        public UrnType(int id, String displayName, UrnCategory category) {&#10;            this.id = id;&#10;            this.displayName = displayName;&#10;            this.category = category;&#10;        }&#10;        &#10;        public int getId() { return id; }&#10;        public String getDisplayName() { return displayName; }&#10;        public UrnCategory getCategory() { return category; }&#10;        &#10;        @Override&#10;        public String toString() {&#10;            return displayName;&#10;        }&#10;    }&#10;    &#10;    // State logic&#10;    private UrnTaskState currentState;&#10;&#10;    // State instances&#10;    private final UrnTaskState mineClayState = new MineClayState();&#10;    private final UrnTaskState goUpstairsState = new GoUpstairsState();&#10;    private final UrnTaskState softenClayState = new SoftenClayState();&#10;    private final UrnTaskState spinUrnsState = new SpinUrnsState();&#10;    private final UrnTaskState fireUrnsState = new FireUrnsState();&#10;    private final UrnTaskState addRunesState = new AddRunesState();&#10;    private final UrnTaskState depositUrnsState = new DepositUrnsState();&#10;&#10;    public ClayUrnTask(CoaezUtility script) {&#10;        this.script = script;&#10;        loadUrnData();&#10;        currentState = depositUrnsState;&#10;    }&#10;    &#10;    private void loadUrnData() {&#10;        try {&#10;            availableCategories = new ArrayList&lt;&gt;();&#10;            availableUrns = new ArrayList&lt;&gt;();&#10;            &#10;            ScriptConsole.println(&quot;[ClayUrnTask] Attempting to load urn data from enum &quot; + POTTERY_GROUP_ENUM_ID);&#10;            &#10;            // Load the main pottery group enum&#10;            EnumType potteryGroupEnum = ConfigManager.getEnumType(POTTERY_GROUP_ENUM_ID);&#10;            if (potteryGroupEnum == null) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Error: ConfigManager.getEnumType(&quot; + POTTERY_GROUP_ENUM_ID + &quot;) returned null&quot;);&#10;                return;&#10;            }&#10;            if (potteryGroupEnum.getOutputs() == null) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Error: Enum &quot; + POTTERY_GROUP_ENUM_ID + &quot; has no outputs&quot;);&#10;                return;&#10;            }&#10;            &#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully loaded pottery group enum with &quot; + potteryGroupEnum.getOutputs().size() + &quot; outputs&quot;);&#10;            &#10;            // Process each category enum ID from the main group&#10;            for (int i = 0; i &lt; potteryGroupEnum.getOutputs().size(); i++) {&#10;                Object categoryEnumIdObj = potteryGroupEnum.getOutputs().get(i);&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Processing output &quot; + i + &quot;: &quot; + categoryEnumIdObj + &quot; (type: &quot; + (categoryEnumIdObj != null ? categoryEnumIdObj.getClass().getSimpleName() : &quot;null&quot;) + &quot;)&quot;);&#10;                &#10;                if (categoryEnumIdObj instanceof Integer) {&#10;                    int categoryEnumId = (Integer) categoryEnumIdObj;&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Loading category enum &quot; + categoryEnumId);&#10;                    &#10;                    // Load the category enum to get its name and products&#10;                    EnumType categoryEnum = ConfigManager.getEnumType(categoryEnumId);&#10;                    if (categoryEnum == null) {&#10;                        ScriptConsole.println(&quot;[ClayUrnTask] Warning: Failed to load category enum &quot; + categoryEnumId + &quot;, skipping&quot;);&#10;                        continue;&#10;                    }&#10;                    if (categoryEnum.getOutputs() == null) {&#10;                        ScriptConsole.println(&quot;[ClayUrnTask] Warning: Category enum &quot; + categoryEnumId + &quot; has no outputs, skipping&quot;);&#10;                        continue;&#10;                    }&#10;                    &#10;                    // Create category&#10;                    UrnCategory category = new UrnCategory(i, getCategoryDisplayName(i), categoryEnumId);&#10;                    availableCategories.add(category);&#10;                    &#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Category &quot; + i + &quot;: &quot; + category.getDisplayName() + &quot; (enum &quot; + categoryEnumId + &quot;) with &quot; + categoryEnum.getOutputs().size() + &quot; products&quot;);&#10;                    &#10;                    // Process products in this category&#10;                    for (Object productIdObj : categoryEnum.getOutputs()) {&#10;                        if (productIdObj instanceof Integer) {&#10;                            int productId = (Integer) productIdObj;&#10;                            &#10;                            // Get item details from ConfigManager&#10;                            ItemType itemType = ConfigManager.getItemType(productId);&#10;                            if (itemType != null &amp;&amp; itemType.getName() != null) {&#10;                                String itemName = itemType.getName();&#10;                                // Filter for unfired urns only&#10;                                if (itemName.contains(&quot;urn&quot;) &amp;&amp; itemName.contains(&quot;unfired&quot;)) {&#10;                                    UrnType urn = new UrnType(productId, itemName, category);&#10;                                    availableUrns.add(urn);&#10;                                    ScriptConsole.println(&quot;[ClayUrnTask]   - &quot; + itemName + &quot; (ID: &quot; + productId + &quot;)&quot;);&#10;                                }&#10;                            } else {&#10;                                ScriptConsole.println(&quot;[ClayUrnTask]   - Warning: Could not get item type for ID &quot; + productId);&#10;                            }&#10;                        } else {&#10;                            ScriptConsole.println(&quot;[ClayUrnTask]   - Warning: Non-integer product ID: &quot; + productIdObj);&#10;                        }&#10;                    }&#10;                } else {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Warning: Non-integer category enum ID: &quot; + categoryEnumIdObj);&#10;                }&#10;            }&#10;            &#10;            // Set default selections&#10;            if (!availableCategories.isEmpty()) {&#10;                selectedCategory = availableCategories.get(0);&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Set default category: &quot; + selectedCategory.getDisplayName());&#10;                if (!availableUrns.isEmpty()) {&#10;                    selectedUrn = availableUrns.get(0);&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Set default urn: &quot; + selectedUrn.getDisplayName());&#10;                }&#10;            }&#10;            &#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully loaded &quot; + availableCategories.size() + &quot; categories and &quot; + availableUrns.size() + &quot; urn types&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Error loading urn data: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;    &#10;    private String getCategoryDisplayName(int index) {&#10;        // Map the index to readable names based on the enum data you provided&#10;        switch (index) {&#10;            case 0: return &quot;Pottery&quot;;&#10;            case 1: return &quot;Cooking Urns&quot;;&#10;            case 2: return &quot;Divination Urns&quot;;&#10;            case 3: return &quot;Farming Urns&quot;;&#10;            case 4: return &quot;Fishing Urns&quot;;&#10;            case 5: return &quot;Hunter Urns&quot;;&#10;            case 6: return &quot;Mining Urns&quot;;&#10;            case 7: return &quot;Prayer Urns&quot;;&#10;            case 8: return &quot;Runecrafting Urns&quot;;&#10;            case 9: return &quot;Smelting Urns&quot;;&#10;            case 10: return &quot;Woodcutting Urns&quot;;&#10;            default: return &quot;Category &quot; + index;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void execute() {&#10;        if (!isDataLoaded()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Urn data not yet loaded, attempting to load...&quot;);&#10;            loadUrnData();&#10;            if (!isDataLoaded()) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Failed to load urn data, cannot proceed&quot;);&#10;                Execution.delay(1000);&#10;                return;&#10;            }&#10;        }&#10;        if (currentState != null) {&#10;            currentState.handle(this);&#10;        }&#10;    }&#10;&#10;    // State transition helpers&#10;    public void setStateToMineClay() { currentState = mineClayState; }&#10;    public void setStateToGoUpstairs() { currentState = goUpstairsState; }&#10;    public void setStateToSoftenClay() { currentState = softenClayState; }&#10;    public void setStateToSpinUrns() { currentState = spinUrnsState; }&#10;    public void setStateToFireUrns() { currentState = fireUrnsState; }&#10;    public void setStateToAddRunes() { currentState = addRunesState; }&#10;    public void setStateToDepositUrns() { currentState = depositUrnsState; }&#10;&#10;    void handleMineClayUnderground() {&#10;        // Only transition if backpack is full&#10;        if (Backpack.isFull()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Backpack full, transitioning to upstairs&quot;);&#10;            setStateToGoUpstairs();&#10;            return;&#10;        }&#10;&#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;&#10;        EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Clay rock&quot;).option(&quot;Mine&quot;).results();&#10;        SceneObject rock = results.nearest();&#10;&#10;        boolean hasRockInRange = false;&#10;        if (rock != null &amp;&amp; rock.getCoordinate() != null &amp;&amp; Client.getLocalPlayer() != null &amp;&amp; Client.getLocalPlayer().getCoordinate() != null) {&#10;            double distanceToRock = Distance.between(Client.getLocalPlayer().getCoordinate(), rock.getCoordinate());&#10;            hasRockInRange = distanceToRock &lt;= 25.0;&#10;        }&#10;&#10;        if (!hasRockInRange) {&#10;            if (attemptEnterUnderground()) {&#10;                return;&#10;            }&#10;            Execution.delay(script.getRandom().nextInt(800, 1400));&#10;            return;&#10;        }&#10;&#10;        boolean isMining = Client.getLocalPlayer() != null &amp;&amp; Client.getLocalPlayer().getAnimationId() != -1;&#10;        if (!isMining || isAdrenalineLow()) {&#10;            if (rock != null &amp;&amp; rock.interact(&quot;Mine&quot;)) {&#10;                Execution.delay(script.getRandom().nextInt(1500, 3000));&#10;            } else {&#10;                Execution.delay(script.getRandom().nextInt(600, 1200));&#10;            }&#10;        } else {&#10;            Execution.delay(script.getRandom().nextInt(800, 1400));&#10;        }&#10;    }&#10;    &#10;    void handleGoUpstairs() {&#10;        // Only transition if we have reached upstairs (simulate by successful exit interaction)&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Going upstairs...&quot;);&#10;        &#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;        &#10;        // Look for cave exit to go upstairs&#10;        EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Cave&quot;).option(&quot;Exit&quot;).results();&#10;        SceneObject caveExit = results.nearest();&#10;        &#10;        if (caveExit != null &amp;&amp; caveExit.interact(&quot;Exit&quot;)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Exiting cave, transitioning to soften clay&quot;);&#10;            Execution.delay(script.getRandom().nextInt(4000, 5000));&#10;            setStateToSoftenClay();&#10;        }&#10;&#10;        if(caveExit == null){&#10;            setStateToSoftenClay();&#10;        }&#10;    }&#10;&#10;    void handleSoftenClayAtSink() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Softening clay at sink...&quot;);&#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;        if (Interfaces.isOpen(1370)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Sink interface is open, confirming softening clay&quot;);&#10;            MiniMenu.interact(ComponentAction.DIALOGUE.getType(), 0, -1, 89784350);&#10;            return;&#10;        }&#10;        // Fill sink until no regular clay and all clay in backpack is soft clay&#10;        if (!Backpack.contains(&quot;Clay&quot;)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No regular clay in backpack, moving to spin urns&quot;);&#10;            setStateToSpinUrns();&#10;            return;&#10;        }&#10;        // Otherwise, interact with sink to fill&#10;        EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Sink&quot;).hidden(false).option(&quot;Fill&quot;).results();&#10;        SceneObject sink = results.nearest();&#10;        if (sink != null) {&#10;            if (sink.interact(&quot;Fill&quot;)) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Using sink to soften clay&quot;);&#10;                Execution.delayUntil(10000, () -&gt; Interfaces.isOpen(1370));&#10;                return;&#10;            }&#10;        }&#10;    }&#10;    &#10;    void handleSpinUrns() {&#10;        // Only spin urns if we have enough soft clay for the selected urn&#10;        if (!isDataLoaded() || selectedUrn == null) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No urn selected or data not loaded&quot;);&#10;            Execution.delay(1000);&#10;            return;&#10;        }&#10;&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;&#10;        // Check for at least 2 soft clay before attempting to craft&#10;        int softClayCount = Backpack.getItems().stream()&#10;                .filter(item -&gt; item != null &amp;&amp; &quot;Soft clay&quot;.equals(item.getName()))&#10;                .mapToInt(item -&gt; item.getStackSize())&#10;                .sum();&#10;        if (softClayCount &lt; 2) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Not enough soft clay (need at least 2), transitioning to mining.&quot;);&#10;            setStateToFireUrns();&#10;            return;&#10;        }&#10;&#10;        // Check if pottery wheel interface is open&#10;        if (Interfaces.isOpen(1370)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Pottery wheel interface is open, handling urn selection&quot;);&#10;            handlePotteryWheelInterface();&#10;        } else {&#10;            EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Pottery Wheel&quot;).hidden(false).option(&quot;Form&quot;).results();&#10;            SceneObject potteryWheel = results.nearest();&#10;            if (potteryWheel != null) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Found pottery wheel, attempting to open interface&quot;);&#10;                if (potteryWheel.interact(&quot;Form&quot;)) {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Interacting with pottery wheel&quot;);&#10;                    Execution.delay(script.getRandom().nextInt(1500, 3000));&#10;                }&#10;            } else {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Pottery wheel not found&quot;);&#10;                Execution.delay(script.getRandom().nextInt(800, 1200));&#10;            }&#10;        }&#10;    }&#10;    &#10;    void handleFireUrns() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Handling firing urns...&quot;);&#10;        &#10;        // Check if we have unfired urns to fire using pattern matching&#10;        boolean hasUnfiredUrns = Backpack.getItems().stream()&#10;                .anyMatch(item -&gt; item != null &amp;&amp; item.getName() != null &amp;&amp; &#10;                        item.getName().toLowerCase().contains(&quot;unfired&quot;) &amp;&amp; &#10;                        item.getName().toLowerCase().contains(&quot;urn&quot;));&#10;        &#10;        if (!hasUnfiredUrns) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No unfired urns found, transitioning to add runes&quot;);&#10;            setStateToAddRunes();&#10;            return;&#10;        }&#10;        &#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;        &#10;        // Check if pottery oven interface is open&#10;        if (Interfaces.isOpen(1370)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Pottery oven interface is open, confirming firing&quot;);&#10;            confirmFiringUrns();&#10;            return;&#10;        }&#10;        &#10;        // Find and interact with pottery oven&#10;        EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Pottery oven&quot;).option(&quot;Fire&quot;).results();&#10;        SceneObject oven = results.nearest();&#10;        &#10;        if (oven != null) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Found pottery oven, attempting to fire urns&quot;);&#10;            if (oven.interact(&quot;Fire&quot;)) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Interacting with pottery oven&quot;);&#10;                Execution.delay(script.getRandom().nextInt(1500, 3000));&#10;            }&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Pottery oven not found&quot;);&#10;            Execution.delay(script.getRandom().nextInt(800, 1200));&#10;        }&#10;    }&#10;    &#10;    private void confirmFiringUrns() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Confirming firing using dialogue action (component ID: 89784350)&quot;);&#10;        &#10;        if (MiniMenu.interact(ComponentAction.DIALOGUE.getType(), 0, -1, 89784350)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully started firing urns&quot;);&#10;            // Wait for firing to complete&#10;            Execution.delay(script.getRandom().nextInt(2000, 4000));&#10;            &#10;            // Check if we still have unfired urns using pattern matching&#10;            boolean stillHasUnfiredUrns = Backpack.getItems().stream()&#10;                    .anyMatch(item -&gt; item != null &amp;&amp; item.getName() != null &amp;&amp; &#10;                            item.getName().toLowerCase().contains(&quot;unfired&quot;) &amp;&amp; &#10;                            item.getName().toLowerCase().contains(&quot;urn&quot;));&#10;            &#10;            if (!stillHasUnfiredUrns) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] All urns fired, transitioning to deposit&quot;);&#10;                setStateToDepositUrns();&#10;            }&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Failed to start firing using dialogue action&quot;);&#10;        }&#10;    }&#10;    &#10;    void handleAddRunesToUrns() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Adding runes to fired urns...&quot;);&#10;        var urnItem = Backpack.getItems().stream()&#10;            .filter(item -&gt; item != null &amp;&amp; item.getId() != -1 &amp;&amp;&#10;                item.getName().toLowerCase().contains(&quot;no rune&quot;))&#10;            .findFirst().orElse(null);&#10;        if (urnItem == null) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No fired urns needing runes found, transitioning to deposit&quot;);&#10;            setStateToDepositUrns();&#10;            return;&#10;        }&#10;&#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;&#10;        if (Interfaces.isOpen(1370)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Sink interface is open, confirming softening clay&quot;);&#10;            MiniMenu.interact(ComponentAction.DIALOGUE.getType(), 0, -1, 89784350);&#10;            return;&#10;        }&#10;&#10;        // Get options from the urn item&#10;        List&lt;String&gt; options = Objects.requireNonNull(urnItem.getConfigType()).getBackpackOptions();&#10;        if (options == null || options.isEmpty()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No options found for urn item&quot;);&#10;            return;&#10;        }&#10;        String option = options.get(0);&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Interacting with urn: &quot; + urnItem.getName() + &quot; using option: &quot; + option);&#10;        boolean interacted = Backpack.interact(urnItem.getName(), option);&#10;        if (!interacted) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Could not interact with urn to add rune&quot;);&#10;            return;&#10;        }&#10;        Execution.delay(script.getRandom().nextInt(1200, 1800));&#10;    }&#10;&#10;    void handleDepositUrns() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Handling depositing urns...&quot;);&#10;&#10;        // Find all urns with (empty) in their name&#10;        Pattern urnPattern = Pattern.compile(&quot;urn.*\\(empty\\)&quot;, Pattern.CASE_INSENSITIVE);&#10;&#10;        // Try to open deposit box if not already open&#10;        if (!DepositBox.isOpen()) {&#10;            EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Bank deposit box&quot;).hidden(false).option(&quot;Deposit&quot;).results();&#10;            SceneObject depositBox = results.nearest();&#10;            if (depositBox != null &amp;&amp; depositBox.interact(&quot;Deposit&quot;)) {&#10;                boolean opened = Execution.delayUntil(10000, () -&gt; DepositBox.isOpen());&#10;                if (!opened) {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Deposit box did not open in time&quot;);&#10;                    return;&#10;                }&#10;            } else {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Deposit box not found or failed to interact, using bank preset&quot;);&#10;                Bank.loadLastPreset();&#10;                Execution.delay(script.getRandom().nextInt(5000, 7000));&#10;                return;&#10;            }&#10;        }&#10;&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Deposit box is open, attempting to deposit urns...&quot;);&#10;        boolean deposited = DepositBox.depositAll(urnPattern);&#10;        if (deposited) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] DepositBox.depositAll returned true. All urns should be deposited.&quot;);&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] DepositBox.depositAll returned false. No urns were deposited or an error occurred.&quot;);&#10;        }&#10;        // Print current backpack urns for debug&#10;        List&lt;String&gt; remainingUrns = Backpack.getItems().stream()&#10;            .filter(item -&gt; item != null &amp;&amp; item.getName() != null &amp;&amp; item.getName().toLowerCase().contains(&quot;urn&quot;) &amp;&amp; item.getName().toLowerCase().contains(&quot;(empty)&quot;))&#10;            .map(item -&gt; item.getName())&#10;            .toList();&#10;        if (remainingUrns.isEmpty()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No urns remain in backpack after deposit.&quot;);&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Urns still in backpack after deposit: &quot; + remainingUrns);&#10;        }&#10;        Execution.delay(script.getRandom().nextInt(500, 1200));&#10;    }&#10;&#10;    private void handlePotteryWheelInterface() {&#10;&#10;        // Get current category and item selection from VarManager&#10;        int currentCategoryVar = VarManager.getVarValue(VarDomainType.PLAYER, 1169);&#10;        int currentItemVar = VarManager.getVarValue(VarDomainType.PLAYER, 1170);&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Current category var: &quot; + currentCategoryVar + &quot;, current item var: &quot; + currentItemVar);&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Target urn ID: &quot; + selectedUrn.getId());&#10;        &#10;        // Check what urn name is currently displayed in component 13&#10;        var currentUrnNameComponent = ComponentQuery.newQuery(1370).componentIndex(13).results().first();&#10;        if (currentUrnNameComponent != null) {&#10;            String currentUrnText = currentUrnNameComponent.getText();&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Currently displayed urn: &quot; + currentUrnText);&#10;        }&#10;        &#10;        // Check if correct category is selected&#10;        if (currentCategoryVar != selectedCategory.getEnumId()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Incorrect category selected, selecting correct category: &quot; + selectedCategory);&#10;            selectUrnCategory(selectedCategory);&#10;            return;&#10;        }&#10;        &#10;        // Check if correct urn is selected&#10;        if (currentItemVar == selectedUrn.getId()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Correct urn already selected: &quot; + selectedUrn.getDisplayName());&#10;            &#10;            // Check if we can make the urn (similar to herblore checking var 8847)&#10;            int canMakeVar = VarManager.getVarValue(VarDomainType.PLAYER, 8847);&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Can make urn check (var 8847): &quot; + canMakeVar);&#10;            &#10;            if (canMakeVar &lt;= 0) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Cannot make urn, no materials or requirements not met&quot;);&#10;                Execution.delay(script.getRandom().nextInt(800, 1200));&#10;                return;&#10;            }&#10;            &#10;            // Proceed with crafting&#10;            if (craftUrn()) {&#10;                // Wait for crafting to complete&#10;                Execution.delay(script.getRandom().nextInt(2000, 4000));&#10;                // Check if we still have soft clay&#10;                if (!Backpack.contains(&quot;Soft clay&quot;)) {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] No more soft clay, transitioning to firing&quot;);&#10;                    setStateToFireUrns();&#10;                } else {&#10;                    // If we still have enough soft clay for another urn, stay in SPIN_URNS&#10;                    int requiredSoftClay = getRequiredSoftClayForUrn(selectedUrn);&#10;                    int softClayCount = Backpack.getItems().stream()&#10;                        .filter(item -&gt; item != null &amp;&amp; &quot;Soft clay&quot;.equals(item.getName()))&#10;                        .mapToInt(item -&gt; item.getStackSize())&#10;                        .sum();&#10;                    if (softClayCount &lt; requiredSoftClay) {&#10;                        ScriptConsole.println(&quot;[ClayUrnTask] Not enough soft clay for another urn, transitioning to firing&quot;);&#10;                        setStateToFireUrns();&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Incorrect urn selected, selecting correct urn: &quot; + selectedUrn.getDisplayName());&#10;            selectUrnItem(selectedUrn);&#10;        }&#10;    }&#10;&#10;    private void selectUrnCategory(UrnCategory category) {&#10;        // Only log if interacting with interface 1370&#10;        int dropdownComponentId = 89849884;&#10;        if (dropdownComponentId == 1370) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Selecting category: &quot; + category);&#10;        }&#10;        MiniMenu.interact(ComponentAction.COMPONENT.getType(), 1, -1, dropdownComponentId);&#10;        Execution.delay(script.getRandom().nextInt(100, 200));&#10;        int categoryIndex = category.getIndex();&#10;        int componentIndex = (categoryIndex * 2) + 1;&#10;        int categoryComponentId = 96797588;&#10;        if (categoryComponentId == 1370) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Selected category: &quot; + category + &quot; at index: &quot; + categoryIndex);&#10;        }&#10;        MiniMenu.interact(ComponentAction.COMPONENT.getType(), 1, componentIndex, categoryComponentId);&#10;        Execution.delay(script.getRandom().nextInt(300, 800));&#10;    }&#10;&#10;    private void selectUrnItem(UrnType urn) {&#10;        // Only log if interacting with interface 1370&#10;        int categoryComponentId = 96797588;&#10;        if (categoryComponentId == 1370) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Attempting to select urn: &quot; + urn.getDisplayName() + &quot; (ID: &quot; + urn.getId() + &quot;)&quot;);&#10;        }&#10;        int currentCategoryVar = VarManager.getVarValue(VarDomainType.PLAYER, 1169);&#10;        EnumType categoryEnum = ConfigManager.getEnumType(currentCategoryVar);&#10;        if (categoryEnum == null || categoryEnum.getOutputs() == null) {&#10;            if (categoryComponentId == 1370) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Error: Could not get category enum for var &quot; + currentCategoryVar);&#10;            }&#10;            return;&#10;        }&#10;        &#10;        // Find the urn's index in the category enum&#10;        int urnEnumIndex = -1;&#10;        for (int i = 0; i &lt; categoryEnum.getOutputs().size(); i++) {&#10;            Object output = categoryEnum.getOutputs().get(i);&#10;            if (output instanceof Integer &amp;&amp; (Integer) output == urn.getId()) {&#10;                urnEnumIndex = i;&#10;                break;&#10;            }&#10;        }&#10;        &#10;        if (urnEnumIndex == -1) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Error: Could not find urn &quot; + urn.getId() + &quot; in category enum&quot;);&#10;            return;&#10;        }&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Found urn at enum index: &quot; + urnEnumIndex);&#10;        &#10;        // Use the same formula as herblore: (index * 4) + 1&#10;        int componentIndex = (urnEnumIndex * 4) + 1;&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Using component index: &quot; + componentIndex + &quot; (enum index &quot; + urnEnumIndex + &quot; * 4 + 1) with component ID: 89849878&quot;);&#10;        &#10;        // Use MiniMenu.interact directly with the component ID and calculated component index&#10;        if (MiniMenu.interact(ComponentAction.COMPONENT.getType(), 1, componentIndex, 89849878)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] MiniMenu.interact returned true, verifying selection...&quot;);&#10;            &#10;            // Wait a moment for the selection to take effect&#10;            Execution.delay(script.getRandom().nextInt(300, 600));&#10;            &#10;            // Verify the selection actually worked by checking the current item var&#10;            int newCurrentItemVar = VarManager.getVarValue(VarDomainType.PLAYER, 1170);&#10;            ScriptConsole.println(&quot;[ClayUrnTask] After selection, current item var: &quot; + newCurrentItemVar + &quot; (target: &quot; + urn.getId() + &quot;)&quot;);&#10;            &#10;            if (newCurrentItemVar == urn.getId()) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Successfully selected urn: &quot; + urn.getDisplayName() + &quot; using enum index &quot; + urnEnumIndex);&#10;                Execution.delay(script.getRandom().nextInt(300, 800));&#10;                return;&#10;            } else {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Selection failed - current item var did not change to target urn ID&quot;);&#10;                // Try again with a different approach or log error&#10;                return;&#10;            }&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Failed to select urn using MiniMenu.interact&quot;);&#10;        }&#10;        &#10;        Execution.delay(script.getRandom().nextInt(300, 800));&#10;    }&#10;&#10;    private boolean craftUrn() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Starting urn crafting using dialogue action (component ID: 89784350)&quot;);&#10;        &#10;        if (MiniMenu.interact(ComponentAction.DIALOGUE.getType(), 0, -1, 89784350)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully started crafting urn&quot;);&#10;            return true;&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Failed to start crafting using dialogue action&quot;);&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // Getters and setters for GUI configuration&#10;    public UrnCategory getSelectedCategory() {&#10;        return selectedCategory;&#10;    }&#10;    &#10;    public void setSelectedCategory(UrnCategory category) {&#10;        if (category != null &amp;&amp; availableCategories.contains(category)) {&#10;            this.selectedCategory = category;&#10;            // Update selected urn to match the category if needed&#10;            if (selectedUrn != null &amp;&amp; selectedUrn.getCategory() != category) {&#10;                // Find first urn in the new category&#10;                for (UrnType urn : availableUrns) {&#10;                    if (urn.getCategory() == category) {&#10;                        selectedUrn = urn;&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    public UrnType getSelectedUrn() {&#10;        return selectedUrn;&#10;    }&#10;    &#10;    public void setSelectedUrn(UrnType urn) {&#10;        if (urn != null &amp;&amp; availableUrns.contains(urn)) {&#10;            this.selectedUrn = urn;&#10;            this.selectedCategory = urn.getCategory();&#10;        }&#10;    }&#10;    &#10;    public UrnCategory[] getAvailableCategories() {&#10;        if (availableCategories == null) {&#10;            return new UrnCategory[0];&#10;        }&#10;        return availableCategories.toArray(new UrnCategory[0]);&#10;    }&#10;    &#10;    public UrnType[] getUrnsInCategory(UrnCategory category) {&#10;        if (availableUrns == null || category == null) {&#10;            return new UrnType[0];&#10;        }&#10;        return availableUrns.stream()&#10;                .filter(urn -&gt; urn.getCategory() == category)&#10;                .toArray(UrnType[]::new);&#10;    }&#10;    &#10;    public UrnType[] getAllAvailableUrns() {&#10;        if (availableUrns == null) {&#10;            return new UrnType[0];&#10;        }&#10;        return availableUrns.toArray(new UrnType[0]);&#10;    }&#10;    &#10;    public boolean isDataLoaded() {&#10;        return availableCategories != null &amp;&amp; availableUrns != null &amp;&amp; &#10;               !availableCategories.isEmpty() &amp;&amp; !availableUrns.isEmpty();&#10;    }&#10;    &#10;    public void reloadUrnData() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Reloading urn data...&quot;);&#10;        loadUrnData();&#10;        if (isDataLoaded()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully reloaded urn data&quot;);&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Failed to reload urn data&quot;);&#10;        }&#10;    }&#10;    &#10;    public String getStatus() {&#10;        if (!isDataLoaded()) {&#10;            return &quot;Data not loaded&quot;;&#10;        }&#10;        if (selectedCategory == null || selectedUrn == null) {&#10;            return &quot;No urn selected&quot;;&#10;        }&#10;        return &quot;Selected: &quot; + selectedUrn.getDisplayName() + &quot; (&quot; + selectedCategory.getDisplayName() + &quot;)&quot;;&#10;    }&#10;    &#10;    public boolean setSelectedUrnById(int urnId) {&#10;        if (!isDataLoaded()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Cannot set urn by ID: data not loaded&quot;);&#10;            return false;&#10;        }&#10;        &#10;        for (UrnType urn : availableUrns) {&#10;            if (urn.getId() == urnId) {&#10;                setSelectedUrn(urn);&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Set urn by ID: &quot; + urn.getDisplayName());&#10;                return true;&#10;            }&#10;        }&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Urn with ID &quot; + urnId + &quot; not found in available urns&quot;);&#10;        return false;&#10;    }&#10;    &#10;    public void printAvailableUrns() {&#10;        if (!isDataLoaded()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No urn data available&quot;);&#10;            return;&#10;        }&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Available urn categories:&quot;);&#10;        for (UrnCategory category : availableCategories) {&#10;            ScriptConsole.println(&quot;  &quot; + category.getIndex() + &quot;: &quot; + category.getDisplayName() + &quot; (enum &quot; + category.getEnumId() + &quot;)&quot;);&#10;        }&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Available urn types:&quot;);&#10;        for (UrnType urn : availableUrns) {&#10;            ScriptConsole.println(&quot;  &quot; + urn.getId() + &quot;: &quot; + urn.getDisplayName() + &quot; (&quot; + urn.getCategory().getDisplayName() + &quot;)&quot;);&#10;        }&#10;    }&#10;&#10;    private boolean attemptEnterUnderground() {&#10;        SceneObject entrance = SceneObjectQuery.newQuery()&#10;                .name(&quot;Cave entrance&quot;)&#10;                .option(&quot;Enter&quot;)&#10;                .hidden(false)&#10;                .results()&#10;                .nearest();&#10;        if (entrance != null) {&#10;            if (entrance.interact(&quot;Enter&quot;)) {&#10;                Execution.delay(script.getRandom().nextInt(1200, 2200));&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean isAdrenalineLow() {&#10;        try {&#10;            if (Client.getLocalPlayer() == null) return true;&#10;            for (Headbar headbar : Client.getLocalPlayer().getHeadbars()) {&#10;                if (headbar.getId() == 5) { // adrenaline bar&#10;                    return headbar.getWidth() &lt;= 10; // close to bottom&#10;                }&#10;            }&#10;        } catch (Exception ignored) {}&#10;        return true;&#10;    }&#10;&#10;    private int getRequiredSoftClayForUrn(UrnType urn) {&#10;        ItemType itemType = ConfigManager.getItemType(urn.getId());&#10;        if (itemType == null) return 0;&#10;        return itemType.getIntParam(2665); // craft_quantity_1&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package net.botwithus.tasks;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;import java.util.regex.Pattern;&#10;&#10;import net.botwithus.CoaezUtility;&#10;import net.botwithus.api.game.hud.inventories.Backpack;&#10;import net.botwithus.api.game.hud.inventories.Bank;&#10;import net.botwithus.api.game.hud.inventories.DepositBox;&#10;import net.botwithus.rs3.game.Client;&#10;import net.botwithus.rs3.game.Distance;&#10;import net.botwithus.rs3.game.Item;&#10;import net.botwithus.rs3.game.hud.interfaces.Interfaces;&#10;import net.botwithus.rs3.game.js5.types.EnumType;&#10;import net.botwithus.rs3.game.js5.types.ItemType;&#10;import net.botwithus.rs3.game.js5.types.configs.ConfigManager;&#10;import net.botwithus.rs3.game.js5.types.vars.VarDomainType;&#10;import net.botwithus.rs3.game.minimenu.MiniMenu;&#10;import net.botwithus.rs3.game.minimenu.actions.ComponentAction;&#10;import net.botwithus.rs3.game.queries.builders.components.ComponentQuery;&#10;import net.botwithus.rs3.game.queries.builders.objects.SceneObjectQuery;&#10;import net.botwithus.rs3.game.queries.results.EntityResultSet;&#10;import net.botwithus.rs3.game.scene.entities.characters.Headbar;&#10;import net.botwithus.rs3.game.scene.entities.object.SceneObject;&#10;import net.botwithus.rs3.game.vars.VarManager;&#10;import net.botwithus.rs3.script.Execution;&#10;import net.botwithus.rs3.script.ScriptConsole;&#10;import net.botwithus.rs3.game.hud.interfaces.Component;&#10;&#10;public class ClayUrnTask implements Task {&#10;    private final CoaezUtility script;&#10;    &#10;    // Enum ID for pottery crafting groups&#10;    private static final int POTTERY_GROUP_ENUM_ID = 7004;&#10;    &#10;    // Dynamic urn categories and types loaded from game data&#10;    private List&lt;UrnCategory&gt; availableCategories;&#10;    private List&lt;UrnType&gt; availableUrns;&#10;    &#10;    // Default selections - will be updated when data is loaded&#10;    private UrnCategory selectedCategory;&#10;    private UrnType selectedUrn;&#10;    &#10;    public static class UrnCategory {&#10;        private final int index;&#10;        private final String displayName;&#10;        private final int enumId;&#10;        &#10;        public UrnCategory(int index, String displayName, int enumId) {&#10;            this.index = index;&#10;            this.displayName = displayName;&#10;            this.enumId = enumId;&#10;        }&#10;        &#10;        public int getIndex() { return index; }&#10;        public String getDisplayName() { return displayName; }&#10;        public int getEnumId() { return enumId; }&#10;        &#10;        @Override&#10;        public String toString() {&#10;            return displayName;&#10;        }&#10;    }&#10;    &#10;    public static class UrnType {&#10;        private final int id;&#10;        private final String displayName;&#10;        private final UrnCategory category;&#10;        &#10;        public UrnType(int id, String displayName, UrnCategory category) {&#10;            this.id = id;&#10;            this.displayName = displayName;&#10;            this.category = category;&#10;        }&#10;        &#10;        public int getId() { return id; }&#10;        public String getDisplayName() { return displayName; }&#10;        public UrnCategory getCategory() { return category; }&#10;        &#10;        @Override&#10;        public String toString() {&#10;            return displayName;&#10;        }&#10;    }&#10;    &#10;    // State logic&#10;    private UrnTaskState currentState;&#10;&#10;    // State instances&#10;    private final UrnTaskState mineClayState = new MineClayState();&#10;    private final UrnTaskState goUpstairsState = new GoUpstairsState();&#10;    private final UrnTaskState softenClayState = new SoftenClayState();&#10;    private final UrnTaskState spinUrnsState = new SpinUrnsState();&#10;    private final UrnTaskState fireUrnsState = new FireUrnsState();&#10;    private final UrnTaskState addRunesState = new AddRunesState();&#10;    private final UrnTaskState depositUrnsState = new DepositUrnsState();&#10;&#10;    public ClayUrnTask(CoaezUtility script) {&#10;        this.script = script;&#10;        loadUrnData();&#10;        currentState = depositUrnsState;&#10;    }&#10;    &#10;    private void loadUrnData() {&#10;        try {&#10;            availableCategories = new ArrayList&lt;&gt;();&#10;            availableUrns = new ArrayList&lt;&gt;();&#10;            &#10;            ScriptConsole.println(&quot;[ClayUrnTask] Attempting to load urn data from enum &quot; + POTTERY_GROUP_ENUM_ID);&#10;            &#10;            // Load the main pottery group enum&#10;            EnumType potteryGroupEnum = ConfigManager.getEnumType(POTTERY_GROUP_ENUM_ID);&#10;            if (potteryGroupEnum == null) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Error: ConfigManager.getEnumType(&quot; + POTTERY_GROUP_ENUM_ID + &quot;) returned null&quot;);&#10;                return;&#10;            }&#10;            if (potteryGroupEnum.getOutputs() == null) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Error: Enum &quot; + POTTERY_GROUP_ENUM_ID + &quot; has no outputs&quot;);&#10;                return;&#10;            }&#10;            &#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully loaded pottery group enum with &quot; + potteryGroupEnum.getOutputs().size() + &quot; outputs&quot;);&#10;            &#10;            // Process each category enum ID from the main group&#10;            for (int i = 0; i &lt; potteryGroupEnum.getOutputs().size(); i++) {&#10;                Object categoryEnumIdObj = potteryGroupEnum.getOutputs().get(i);&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Processing output &quot; + i + &quot;: &quot; + categoryEnumIdObj + &quot; (type: &quot; + (categoryEnumIdObj != null ? categoryEnumIdObj.getClass().getSimpleName() : &quot;null&quot;) + &quot;)&quot;);&#10;                &#10;                if (categoryEnumIdObj instanceof Integer) {&#10;                    int categoryEnumId = (Integer) categoryEnumIdObj;&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Loading category enum &quot; + categoryEnumId);&#10;                    &#10;                    // Load the category enum to get its name and products&#10;                    EnumType categoryEnum = ConfigManager.getEnumType(categoryEnumId);&#10;                    if (categoryEnum == null) {&#10;                        ScriptConsole.println(&quot;[ClayUrnTask] Warning: Failed to load category enum &quot; + categoryEnumId + &quot;, skipping&quot;);&#10;                        continue;&#10;                    }&#10;                    if (categoryEnum.getOutputs() == null) {&#10;                        ScriptConsole.println(&quot;[ClayUrnTask] Warning: Category enum &quot; + categoryEnumId + &quot; has no outputs, skipping&quot;);&#10;                        continue;&#10;                    }&#10;                    &#10;                    // Create category&#10;                    UrnCategory category = new UrnCategory(i, getCategoryDisplayName(i), categoryEnumId);&#10;                    availableCategories.add(category);&#10;                    &#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Category &quot; + i + &quot;: &quot; + category.getDisplayName() + &quot; (enum &quot; + categoryEnumId + &quot;) with &quot; + categoryEnum.getOutputs().size() + &quot; products&quot;);&#10;                    &#10;                    // Process products in this category&#10;                    for (Object productIdObj : categoryEnum.getOutputs()) {&#10;                        if (productIdObj instanceof Integer) {&#10;                            int productId = (Integer) productIdObj;&#10;                            &#10;                            // Get item details from ConfigManager&#10;                            ItemType itemType = ConfigManager.getItemType(productId);&#10;                            if (itemType != null &amp;&amp; itemType.getName() != null) {&#10;                                String itemName = itemType.getName();&#10;                                // Filter for unfired urns only&#10;                                if (itemName.contains(&quot;urn&quot;) &amp;&amp; itemName.contains(&quot;unfired&quot;)) {&#10;                                    UrnType urn = new UrnType(productId, itemName, category);&#10;                                    availableUrns.add(urn);&#10;                                    ScriptConsole.println(&quot;[ClayUrnTask]   - &quot; + itemName + &quot; (ID: &quot; + productId + &quot;)&quot;);&#10;                                }&#10;                            } else {&#10;                                ScriptConsole.println(&quot;[ClayUrnTask]   - Warning: Could not get item type for ID &quot; + productId);&#10;                            }&#10;                        } else {&#10;                            ScriptConsole.println(&quot;[ClayUrnTask]   - Warning: Non-integer product ID: &quot; + productIdObj);&#10;                        }&#10;                    }&#10;                } else {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Warning: Non-integer category enum ID: &quot; + categoryEnumIdObj);&#10;                }&#10;            }&#10;            &#10;            // Set default selections&#10;            if (!availableCategories.isEmpty()) {&#10;                selectedCategory = availableCategories.get(0);&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Set default category: &quot; + selectedCategory.getDisplayName());&#10;                if (!availableUrns.isEmpty()) {&#10;                    selectedUrn = availableUrns.get(0);&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Set default urn: &quot; + selectedUrn.getDisplayName());&#10;                }&#10;            }&#10;            &#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully loaded &quot; + availableCategories.size() + &quot; categories and &quot; + availableUrns.size() + &quot; urn types&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Error loading urn data: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;    &#10;    private String getCategoryDisplayName(int index) {&#10;        // Map the index to readable names based on the enum data you provided&#10;        switch (index) {&#10;            case 0: return &quot;Pottery&quot;;&#10;            case 1: return &quot;Cooking Urns&quot;;&#10;            case 2: return &quot;Divination Urns&quot;;&#10;            case 3: return &quot;Farming Urns&quot;;&#10;            case 4: return &quot;Fishing Urns&quot;;&#10;            case 5: return &quot;Hunter Urns&quot;;&#10;            case 6: return &quot;Mining Urns&quot;;&#10;            case 7: return &quot;Prayer Urns&quot;;&#10;            case 8: return &quot;Runecrafting Urns&quot;;&#10;            case 9: return &quot;Smelting Urns&quot;;&#10;            case 10: return &quot;Woodcutting Urns&quot;;&#10;            default: return &quot;Category &quot; + index;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void execute() {&#10;        if (!isDataLoaded()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Urn data not yet loaded, attempting to load...&quot;);&#10;            loadUrnData();&#10;            if (!isDataLoaded()) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Failed to load urn data, cannot proceed&quot;);&#10;                Execution.delay(1000);&#10;                return;&#10;            }&#10;        }&#10;        if (currentState != null) {&#10;            currentState.handle(this);&#10;        }&#10;    }&#10;&#10;    // State transition helpers&#10;    public void setStateToMineClay() { currentState = mineClayState; }&#10;    public void setStateToGoUpstairs() { currentState = goUpstairsState; }&#10;    public void setStateToSoftenClay() { currentState = softenClayState; }&#10;    public void setStateToSpinUrns() { currentState = spinUrnsState; }&#10;    public void setStateToFireUrns() { currentState = fireUrnsState; }&#10;    public void setStateToAddRunes() { currentState = addRunesState; }&#10;    public void setStateToDepositUrns() { currentState = depositUrnsState; }&#10;&#10;    void handleMineClayUnderground() {&#10;        // Only transition if backpack is full&#10;        if (Backpack.isFull()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Backpack full, transitioning to upstairs&quot;);&#10;            setStateToGoUpstairs();&#10;            return;&#10;        }&#10;&#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;&#10;        EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Clay rock&quot;).option(&quot;Mine&quot;).results();&#10;        SceneObject rock = results.nearest();&#10;&#10;        boolean hasRockInRange = false;&#10;        if (rock != null &amp;&amp; rock.getCoordinate() != null &amp;&amp; Client.getLocalPlayer() != null &amp;&amp; Client.getLocalPlayer().getCoordinate() != null) {&#10;            double distanceToRock = Distance.between(Client.getLocalPlayer().getCoordinate(), rock.getCoordinate());&#10;            hasRockInRange = distanceToRock &lt;= 25.0;&#10;        }&#10;&#10;        if (!hasRockInRange) {&#10;            if (attemptEnterUnderground()) {&#10;                return;&#10;            }&#10;            Execution.delay(script.getRandom().nextInt(800, 1400));&#10;            return;&#10;        }&#10;&#10;        boolean isMining = Client.getLocalPlayer() != null &amp;&amp; Client.getLocalPlayer().getAnimationId() != -1;&#10;        if (!isMining || isAdrenalineLow()) {&#10;            if (rock != null &amp;&amp; rock.interact(&quot;Mine&quot;)) {&#10;                Execution.delay(script.getRandom().nextInt(1500, 3000));&#10;            } else {&#10;                Execution.delay(script.getRandom().nextInt(600, 1200));&#10;            }&#10;        } else {&#10;            Execution.delay(script.getRandom().nextInt(800, 1400));&#10;        }&#10;    }&#10;    &#10;    void handleGoUpstairs() {&#10;        // Only transition if we have reached upstairs (simulate by successful exit interaction)&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Going upstairs...&quot;);&#10;        &#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;        &#10;        // Look for cave exit to go upstairs&#10;        EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Cave&quot;).option(&quot;Exit&quot;).results();&#10;        SceneObject caveExit = results.nearest();&#10;        &#10;        if (caveExit != null &amp;&amp; caveExit.interact(&quot;Exit&quot;)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Exiting cave, transitioning to soften clay&quot;);&#10;            Execution.delay(script.getRandom().nextInt(4000, 5000));&#10;            setStateToSoftenClay();&#10;        }&#10;&#10;        if(caveExit == null){&#10;            setStateToSoftenClay();&#10;        }&#10;    }&#10;&#10;    void handleSoftenClayAtSink() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Softening clay at sink...&quot;);&#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;        if (Interfaces.isOpen(1370)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Sink interface is open, confirming softening clay&quot;);&#10;            MiniMenu.interact(ComponentAction.DIALOGUE.getType(), 0, -1, 89784350);&#10;            return;&#10;        }&#10;        // Fill sink until no regular clay and all clay in backpack is soft clay&#10;        if (!Backpack.contains(&quot;Clay&quot;)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No regular clay in backpack, moving to spin urns&quot;);&#10;            setStateToSpinUrns();&#10;            return;&#10;        }&#10;        // Otherwise, interact with sink to fill&#10;        EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Sink&quot;).hidden(false).option(&quot;Fill&quot;).results();&#10;        SceneObject sink = results.nearest();&#10;        if (sink != null) {&#10;            if (sink.interact(&quot;Fill&quot;)) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Using sink to soften clay&quot;);&#10;                Execution.delayUntil(10000, () -&gt; Interfaces.isOpen(1370));&#10;                return;&#10;            }&#10;        }&#10;    }&#10;    &#10;    void handleSpinUrns() {&#10;        // Only spin urns if we have enough soft clay for the selected urn&#10;        if (!isDataLoaded() || selectedUrn == null) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No urn selected or data not loaded&quot;);&#10;            Execution.delay(1000);&#10;            return;&#10;        }&#10;&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;&#10;        // Check for at least 2 soft clay before attempting to craft&#10;        int softClayCount = Backpack.getItems().stream()&#10;                .filter(item -&gt; item != null &amp;&amp; &quot;Soft clay&quot;.equals(item.getName()))&#10;                .mapToInt(item -&gt; item.getStackSize())&#10;                .sum();&#10;        if (softClayCount &lt; 2) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Not enough soft clay (need at least 2), transitioning to mining.&quot;);&#10;            setStateToFireUrns();&#10;            return;&#10;        }&#10;&#10;        // Check if pottery wheel interface is open&#10;        if (Interfaces.isOpen(1370)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Pottery wheel interface is open, handling urn selection&quot;);&#10;            handlePotteryWheelInterface();&#10;        } else {&#10;            EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Pottery Wheel&quot;).hidden(false).option(&quot;Form&quot;).results();&#10;            SceneObject potteryWheel = results.nearest();&#10;            if (potteryWheel != null) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Found pottery wheel, attempting to open interface&quot;);&#10;                if (potteryWheel.interact(&quot;Form&quot;)) {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Interacting with pottery wheel&quot;);&#10;                    Execution.delay(script.getRandom().nextInt(1500, 3000));&#10;                }&#10;            } else {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Pottery wheel not found&quot;);&#10;                Execution.delay(script.getRandom().nextInt(800, 1200));&#10;            }&#10;        }&#10;    }&#10;    &#10;    void handleFireUrns() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Handling firing urns...&quot;);&#10;        &#10;        // Check if we have unfired urns to fire using pattern matching&#10;        boolean hasUnfiredUrns = Backpack.getItems().stream()&#10;                .anyMatch(item -&gt; item != null &amp;&amp; item.getName() != null &amp;&amp; &#10;                        item.getName().toLowerCase().contains(&quot;unfired&quot;) &amp;&amp; &#10;                        item.getName().toLowerCase().contains(&quot;urn&quot;));&#10;        &#10;        if (!hasUnfiredUrns) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No unfired urns found, transitioning to add runes&quot;);&#10;            setStateToAddRunes();&#10;            return;&#10;        }&#10;        &#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;        &#10;        // Check if pottery oven interface is open&#10;        if (Interfaces.isOpen(1370)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Pottery oven interface is open, confirming firing&quot;);&#10;            confirmFiringUrns();&#10;            return;&#10;        }&#10;        &#10;        // Find and interact with pottery oven&#10;        EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Pottery oven&quot;).option(&quot;Fire&quot;).results();&#10;        SceneObject oven = results.nearest();&#10;        &#10;        if (oven != null) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Found pottery oven, attempting to fire urns&quot;);&#10;            if (oven.interact(&quot;Fire&quot;)) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Interacting with pottery oven&quot;);&#10;                Execution.delay(script.getRandom().nextInt(1500, 3000));&#10;            }&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Pottery oven not found&quot;);&#10;            Execution.delay(script.getRandom().nextInt(800, 1200));&#10;        }&#10;    }&#10;    &#10;    private void confirmFiringUrns() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Confirming firing using dialogue action (component ID: 89784350)&quot;);&#10;        &#10;        if (MiniMenu.interact(ComponentAction.DIALOGUE.getType(), 0, -1, 89784350)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully started firing urns&quot;);&#10;            // Wait for firing to complete&#10;            Execution.delay(script.getRandom().nextInt(2000, 4000));&#10;            &#10;            // Check if we still have unfired urns using pattern matching&#10;            boolean stillHasUnfiredUrns = Backpack.getItems().stream()&#10;                    .anyMatch(item -&gt; item != null &amp;&amp; item.getName() != null &amp;&amp; &#10;                            item.getName().toLowerCase().contains(&quot;unfired&quot;) &amp;&amp; &#10;                            item.getName().toLowerCase().contains(&quot;urn&quot;));&#10;            &#10;            if (!stillHasUnfiredUrns) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] All urns fired, transitioning to deposit&quot;);&#10;                setStateToDepositUrns();&#10;            }&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Failed to start firing using dialogue action&quot;);&#10;        }&#10;    }&#10;    &#10;    void handleAddRunesToUrns() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Adding runes to fired urns...&quot;);&#10;        var urnItem = Backpack.getItems().stream()&#10;            .filter(item -&gt; item != null &amp;&amp; item.getId() != -1 &amp;&amp;&#10;                item.getName().toLowerCase().contains(&quot;no rune&quot;))&#10;            .findFirst().orElse(null);&#10;        if (urnItem == null) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No fired urns needing runes found, transitioning to deposit&quot;);&#10;            setStateToDepositUrns();&#10;            return;&#10;        }&#10;&#10;        // Basic interface handling for dialogs&#10;        if (Interfaces.isOpen(1251)) {&#10;            Execution.delayUntil(14000L, () -&gt; !Interfaces.isOpen(1251));&#10;            return;&#10;        }&#10;&#10;        if (Interfaces.isOpen(1370)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Sink interface is open, confirming softening clay&quot;);&#10;            MiniMenu.interact(ComponentAction.DIALOGUE.getType(), 0, -1, 89784350);&#10;            return;&#10;        }&#10;&#10;        // Get options from the urn item&#10;        List&lt;String&gt; options = Objects.requireNonNull(urnItem.getConfigType()).getBackpackOptions();&#10;        if (options == null || options.isEmpty()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No options found for urn item&quot;);&#10;            return;&#10;        }&#10;        String option = options.get(0);&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Interacting with urn: &quot; + urnItem.getName() + &quot; using option: &quot; + option);&#10;        boolean interacted = Backpack.interact(urnItem.getName(), option);&#10;        if (!interacted) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Could not interact with urn to add rune&quot;);&#10;            return;&#10;        }&#10;        Execution.delay(script.getRandom().nextInt(1200, 1800));&#10;    }&#10;&#10;    void handleDepositUrns() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Handling depositing urns...&quot;);&#10;&#10;        // Find all urns with (empty) in their name&#10;        Pattern urnPattern = Pattern.compile(&quot;urn.*\\(empty\\)&quot;, Pattern.CASE_INSENSITIVE);&#10;&#10;        // Try to open deposit box if not already open&#10;        if (!DepositBox.isOpen()) {&#10;            EntityResultSet&lt;SceneObject&gt; results = SceneObjectQuery.newQuery().name(&quot;Bank deposit box&quot;).hidden(false).option(&quot;Deposit&quot;).results();&#10;            SceneObject depositBox = results.nearest();&#10;            if (depositBox != null &amp;&amp; depositBox.interact(&quot;Deposit&quot;)) {&#10;                boolean opened = Execution.delayUntil(10000, () -&gt; DepositBox.isOpen());&#10;                if (!opened) {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Deposit box did not open in time&quot;);&#10;                    return;&#10;                }&#10;            } else {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Deposit box not found or failed to interact, using bank preset&quot;);&#10;                Bank.loadLastPreset();&#10;                Execution.delay(script.getRandom().nextInt(5000, 7000));&#10;                return;&#10;            }&#10;        }&#10;&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Deposit box is open, attempting to deposit urns...&quot;);&#10;        // Find all slots with urns matching the pattern&#10;        List&lt;Item&gt; items = Backpack.getItems();&#10;        List&lt;Integer&gt; urnSlots = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; items.size(); i++) {&#10;            Item item = items.get(i);&#10;            if (item != null &amp;&amp; item.getName() != null &amp;&amp; urnPattern.matcher(item.getName()).find()) {&#10;                urnSlots.add(i);&#10;            }&#10;        }&#10;        boolean allDeposited = true;&#10;        for (int slotNum : urnSlots) {&#10;            if (Backpack.getSlot(slotNum) != null) {&#10;                boolean interacted = MiniMenu.interact(ComponentAction.COMPONENT.getType(), 4, slotNum, 720915);&#10;                if (!interacted) {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Failed to interact with deposit box for slot &quot; + slotNum);&#10;                    allDeposited = false;&#10;                    continue;&#10;                }&#10;                boolean removed = Execution.delayUntil(1000L, () -&gt; Backpack.getSlot(slotNum) == null);&#10;                if (!removed) {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] Urn in slot &quot; + slotNum + &quot; was not removed after deposit&quot;);&#10;                    allDeposited = false;&#10;                }&#10;            }&#10;        }&#10;        if (allDeposited) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] All urns should be deposited.&quot;);&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Some urns were not deposited or an error occurred.&quot;);&#10;        }&#10;        // Print current backpack urns for debug&#10;        List&lt;String&gt; remainingUrns = Backpack.getItems().stream()&#10;            .filter(item -&gt; item != null &amp;&amp; item.getName() != null &amp;&amp; item.getName().toLowerCase().contains(&quot;urn&quot;) &amp;&amp; item.getName().toLowerCase().contains(&quot;(empty)&quot;))&#10;            .map(item -&gt; item.getName())&#10;            .toList();&#10;        if (remainingUrns.isEmpty()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No urns remain in backpack after deposit.&quot;);&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Urns still in backpack after deposit: &quot; + remainingUrns);&#10;        }&#10;        Execution.delay(script.getRandom().nextInt(500, 1200));&#10;    }&#10;&#10;    private void handlePotteryWheelInterface() {&#10;&#10;        // Get current category and item selection from VarManager&#10;        int currentCategoryVar = VarManager.getVarValue(VarDomainType.PLAYER, 1169);&#10;        int currentItemVar = VarManager.getVarValue(VarDomainType.PLAYER, 1170);&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Current category var: &quot; + currentCategoryVar + &quot;, current item var: &quot; + currentItemVar);&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Target urn ID: &quot; + selectedUrn.getId());&#10;        &#10;        // Check what urn name is currently displayed in component 13&#10;        var currentUrnNameComponent = ComponentQuery.newQuery(1370).componentIndex(13).results().first();&#10;        if (currentUrnNameComponent != null) {&#10;            String currentUrnText = currentUrnNameComponent.getText();&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Currently displayed urn: &quot; + currentUrnText);&#10;        }&#10;        &#10;        // Check if correct category is selected&#10;        if (currentCategoryVar != selectedCategory.getEnumId()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Incorrect category selected, selecting correct category: &quot; + selectedCategory);&#10;            selectUrnCategory(selectedCategory);&#10;            return;&#10;        }&#10;        &#10;        // Check if correct urn is selected&#10;        if (currentItemVar == selectedUrn.getId()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Correct urn already selected: &quot; + selectedUrn.getDisplayName());&#10;            &#10;            // Check if we can make the urn (similar to herblore checking var 8847)&#10;            int canMakeVar = VarManager.getVarValue(VarDomainType.PLAYER, 8847);&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Can make urn check (var 8847): &quot; + canMakeVar);&#10;            &#10;            if (canMakeVar &lt;= 0) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Cannot make urn, no materials or requirements not met&quot;);&#10;                Execution.delay(script.getRandom().nextInt(800, 1200));&#10;                return;&#10;            }&#10;            &#10;            // Proceed with crafting&#10;            if (craftUrn()) {&#10;                // Wait for crafting to complete&#10;                Execution.delay(script.getRandom().nextInt(2000, 4000));&#10;                // Check if we still have soft clay&#10;                if (!Backpack.contains(&quot;Soft clay&quot;)) {&#10;                    ScriptConsole.println(&quot;[ClayUrnTask] No more soft clay, transitioning to firing&quot;);&#10;                    setStateToFireUrns();&#10;                } else {&#10;                    // If we still have enough soft clay for another urn, stay in SPIN_URNS&#10;                    int requiredSoftClay = getRequiredSoftClayForUrn(selectedUrn);&#10;                    int softClayCount = Backpack.getItems().stream()&#10;                        .filter(item -&gt; item != null &amp;&amp; &quot;Soft clay&quot;.equals(item.getName()))&#10;                        .mapToInt(item -&gt; item.getStackSize())&#10;                        .sum();&#10;                    if (softClayCount &lt; requiredSoftClay) {&#10;                        ScriptConsole.println(&quot;[ClayUrnTask] Not enough soft clay for another urn, transitioning to firing&quot;);&#10;                        setStateToFireUrns();&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Incorrect urn selected, selecting correct urn: &quot; + selectedUrn.getDisplayName());&#10;            selectUrnItem(selectedUrn);&#10;        }&#10;    }&#10;&#10;    private void selectUrnCategory(UrnCategory category) {&#10;        // Only log if interacting with interface 1370&#10;        int dropdownComponentId = 89849884;&#10;        if (dropdownComponentId == 1370) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Selecting category: &quot; + category);&#10;        }&#10;        MiniMenu.interact(ComponentAction.COMPONENT.getType(), 1, -1, dropdownComponentId);&#10;        Execution.delay(script.getRandom().nextInt(100, 200));&#10;        int categoryIndex = category.getIndex();&#10;        int componentIndex = (categoryIndex * 2) + 1;&#10;        int categoryComponentId = 96797588;&#10;        if (categoryComponentId == 1370) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Selected category: &quot; + category + &quot; at index: &quot; + categoryIndex);&#10;        }&#10;        MiniMenu.interact(ComponentAction.COMPONENT.getType(), 1, componentIndex, categoryComponentId);&#10;        Execution.delay(script.getRandom().nextInt(300, 800));&#10;    }&#10;&#10;    private void selectUrnItem(UrnType urn) {&#10;        // Only log if interacting with interface 1370&#10;        int categoryComponentId = 96797588;&#10;        if (categoryComponentId == 1370) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Attempting to select urn: &quot; + urn.getDisplayName() + &quot; (ID: &quot; + urn.getId() + &quot;)&quot;);&#10;        }&#10;        int currentCategoryVar = VarManager.getVarValue(VarDomainType.PLAYER, 1169);&#10;        EnumType categoryEnum = ConfigManager.getEnumType(currentCategoryVar);&#10;        if (categoryEnum == null || categoryEnum.getOutputs() == null) {&#10;            if (categoryComponentId == 1370) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Error: Could not get category enum for var &quot; + currentCategoryVar);&#10;            }&#10;            return;&#10;        }&#10;        &#10;        // Find the urn's index in the category enum&#10;        int urnEnumIndex = -1;&#10;        for (int i = 0; i &lt; categoryEnum.getOutputs().size(); i++) {&#10;            Object output = categoryEnum.getOutputs().get(i);&#10;            if (output instanceof Integer &amp;&amp; (Integer) output == urn.getId()) {&#10;                urnEnumIndex = i;&#10;                break;&#10;            }&#10;        }&#10;        &#10;        if (urnEnumIndex == -1) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Error: Could not find urn &quot; + urn.getId() + &quot; in category enum&quot;);&#10;            return;&#10;        }&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Found urn at enum index: &quot; + urnEnumIndex);&#10;        &#10;        // Use the same formula as herblore: (index * 4) + 1&#10;        int componentIndex = (urnEnumIndex * 4) + 1;&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Using component index: &quot; + componentIndex + &quot; (enum index &quot; + urnEnumIndex + &quot; * 4 + 1) with component ID: 89849878&quot;);&#10;        &#10;        // Use MiniMenu.interact directly with the component ID and calculated component index&#10;        if (MiniMenu.interact(ComponentAction.COMPONENT.getType(), 1, componentIndex, 89849878)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] MiniMenu.interact returned true, verifying selection...&quot;);&#10;            &#10;            // Wait a moment for the selection to take effect&#10;            Execution.delay(script.getRandom().nextInt(300, 600));&#10;            &#10;            // Verify the selection actually worked by checking the current item var&#10;            int newCurrentItemVar = VarManager.getVarValue(VarDomainType.PLAYER, 1170);&#10;            ScriptConsole.println(&quot;[ClayUrnTask] After selection, current item var: &quot; + newCurrentItemVar + &quot; (target: &quot; + urn.getId() + &quot;)&quot;);&#10;            &#10;            if (newCurrentItemVar == urn.getId()) {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Successfully selected urn: &quot; + urn.getDisplayName() + &quot; using enum index &quot; + urnEnumIndex);&#10;                Execution.delay(script.getRandom().nextInt(300, 800));&#10;                return;&#10;            } else {&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Selection failed - current item var did not change to target urn ID&quot;);&#10;                // Try again with a different approach or log error&#10;                return;&#10;            }&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Failed to select urn using MiniMenu.interact&quot;);&#10;        }&#10;        &#10;        Execution.delay(script.getRandom().nextInt(300, 800));&#10;    }&#10;&#10;    private boolean craftUrn() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Starting urn crafting using dialogue action (component ID: 89784350)&quot;);&#10;        &#10;        if (MiniMenu.interact(ComponentAction.DIALOGUE.getType(), 0, -1, 89784350)) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully started crafting urn&quot;);&#10;            return true;&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Failed to start crafting using dialogue action&quot;);&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // Getters and setters for GUI configuration&#10;    public UrnCategory getSelectedCategory() {&#10;        return selectedCategory;&#10;    }&#10;    &#10;    public void setSelectedCategory(UrnCategory category) {&#10;        if (category != null &amp;&amp; availableCategories.contains(category)) {&#10;            this.selectedCategory = category;&#10;            // Update selected urn to match the category if needed&#10;            if (selectedUrn != null &amp;&amp; selectedUrn.getCategory() != category) {&#10;                // Find first urn in the new category&#10;                for (UrnType urn : availableUrns) {&#10;                    if (urn.getCategory() == category) {&#10;                        selectedUrn = urn;&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    public UrnType getSelectedUrn() {&#10;        return selectedUrn;&#10;    }&#10;    &#10;    public void setSelectedUrn(UrnType urn) {&#10;        if (urn != null &amp;&amp; availableUrns.contains(urn)) {&#10;            this.selectedUrn = urn;&#10;            this.selectedCategory = urn.getCategory();&#10;        }&#10;    }&#10;    &#10;    public UrnCategory[] getAvailableCategories() {&#10;        if (availableCategories == null) {&#10;            return new UrnCategory[0];&#10;        }&#10;        return availableCategories.toArray(new UrnCategory[0]);&#10;    }&#10;    &#10;    public UrnType[] getUrnsInCategory(UrnCategory category) {&#10;        if (availableUrns == null || category == null) {&#10;            return new UrnType[0];&#10;        }&#10;        return availableUrns.stream()&#10;                .filter(urn -&gt; urn.getCategory() == category)&#10;                .toArray(UrnType[]::new);&#10;    }&#10;    &#10;    public UrnType[] getAllAvailableUrns() {&#10;        if (availableUrns == null) {&#10;            return new UrnType[0];&#10;        }&#10;        return availableUrns.toArray(new UrnType[0]);&#10;    }&#10;    &#10;    public boolean isDataLoaded() {&#10;        return availableCategories != null &amp;&amp; availableUrns != null &amp;&amp; &#10;               !availableCategories.isEmpty() &amp;&amp; !availableUrns.isEmpty();&#10;    }&#10;    &#10;    public void reloadUrnData() {&#10;        ScriptConsole.println(&quot;[ClayUrnTask] Reloading urn data...&quot;);&#10;        loadUrnData();&#10;        if (isDataLoaded()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Successfully reloaded urn data&quot;);&#10;        } else {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Failed to reload urn data&quot;);&#10;        }&#10;    }&#10;    &#10;    public String getStatus() {&#10;        if (!isDataLoaded()) {&#10;            return &quot;Data not loaded&quot;;&#10;        }&#10;        if (selectedCategory == null || selectedUrn == null) {&#10;            return &quot;No urn selected&quot;;&#10;        }&#10;        return &quot;Selected: &quot; + selectedUrn.getDisplayName() + &quot; (&quot; + selectedCategory.getDisplayName() + &quot;)&quot;;&#10;    }&#10;    &#10;    public boolean setSelectedUrnById(int urnId) {&#10;        if (!isDataLoaded()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] Cannot set urn by ID: data not loaded&quot;);&#10;            return false;&#10;        }&#10;        &#10;        for (UrnType urn : availableUrns) {&#10;            if (urn.getId() == urnId) {&#10;                setSelectedUrn(urn);&#10;                ScriptConsole.println(&quot;[ClayUrnTask] Set urn by ID: &quot; + urn.getDisplayName());&#10;                return true;&#10;            }&#10;        }&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Urn with ID &quot; + urnId + &quot; not found in available urns&quot;);&#10;        return false;&#10;    }&#10;    &#10;    public void printAvailableUrns() {&#10;        if (!isDataLoaded()) {&#10;            ScriptConsole.println(&quot;[ClayUrnTask] No urn data available&quot;);&#10;            return;&#10;        }&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Available urn categories:&quot;);&#10;        for (UrnCategory category : availableCategories) {&#10;            ScriptConsole.println(&quot;  &quot; + category.getIndex() + &quot;: &quot; + category.getDisplayName() + &quot; (enum &quot; + category.getEnumId() + &quot;)&quot;);&#10;        }&#10;        &#10;        ScriptConsole.println(&quot;[ClayUrnTask] Available urn types:&quot;);&#10;        for (UrnType urn : availableUrns) {&#10;            ScriptConsole.println(&quot;  &quot; + urn.getId() + &quot;: &quot; + urn.getDisplayName() + &quot; (&quot; + urn.getCategory().getDisplayName() + &quot;)&quot;);&#10;        }&#10;    }&#10;&#10;    private boolean attemptEnterUnderground() {&#10;        SceneObject entrance = SceneObjectQuery.newQuery()&#10;                .name(&quot;Cave entrance&quot;)&#10;                .option(&quot;Enter&quot;)&#10;                .hidden(false)&#10;                .results()&#10;                .nearest();&#10;        if (entrance != null) {&#10;            if (entrance.interact(&quot;Enter&quot;)) {&#10;                Execution.delay(script.getRandom().nextInt(1200, 2200));&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean isAdrenalineLow() {&#10;        try {&#10;            if (Client.getLocalPlayer() == null) return true;&#10;            for (Headbar headbar : Client.getLocalPlayer().getHeadbars()) {&#10;                if (headbar.getId() == 5) { // adrenaline bar&#10;                    return headbar.getWidth() &lt;= 10; // close to bottom&#10;                }&#10;            }&#10;        } catch (Exception ignored) {}&#10;        return true;&#10;    }&#10;&#10;    private int getRequiredSoftClayForUrn(UrnType urn) {&#10;        ItemType itemType = ConfigManager.getItemType(urn.getId());&#10;        if (itemType == null) return 0;&#10;        return itemType.getIntParam(2665); // craft_quantity_1&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/DepositUrnsState.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/DepositUrnsState.java" />
              <option name="updatedContent" value="package net.botwithus.tasks;&#10;&#10;public class DepositUrnsState implements UrnTaskState {&#10;    @Override&#10;    public void handle(ClayUrnTask context) {&#10;        context.handleDepositUrns();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/FireUrnsState.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/FireUrnsState.java" />
              <option name="updatedContent" value="package net.botwithus.tasks;&#10;&#10;public class FireUrnsState implements UrnTaskState {&#10;    @Override&#10;    public void handle(ClayUrnTask context) {&#10;        context.handleFireUrns();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/GoUpstairsState.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/GoUpstairsState.java" />
              <option name="updatedContent" value="package net.botwithus.tasks;&#10;&#10;public class GoUpstairsState implements UrnTaskState {&#10;    @Override&#10;    public void handle(ClayUrnTask context) {&#10;        context.handleGoUpstairs();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/MineClayState.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/MineClayState.java" />
              <option name="updatedContent" value="package net.botwithus.tasks;&#10;&#10;public class MineClayState implements UrnTaskState {&#10;    @Override&#10;    public void handle(ClayUrnTask context) {&#10;        context.handleMineClayUnderground();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/SoftenClayState.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/SoftenClayState.java" />
              <option name="updatedContent" value="package net.botwithus.tasks;&#10;&#10;public class SoftenClayState implements UrnTaskState {&#10;    @Override&#10;    public void handle(ClayUrnTask context) {&#10;        context.handleSoftenClayAtSink();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/SpinUrnsState.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/botwithus/tasks/SpinUrnsState.java" />
              <option name="updatedContent" value="package net.botwithus.tasks;&#10;&#10;public class SpinUrnsState implements UrnTaskState {&#10;    @Override&#10;    public void handle(ClayUrnTask context) {&#10;        context.handleSpinUrns();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>